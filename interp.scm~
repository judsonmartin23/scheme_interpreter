;Author:  Judson Martin
;Class:  CS220
;Assignment:  Lab 6, Scheme Interpreter

(define global-env (list
                    (cons 'read read)
                    (cons 'number? number?)
                    (cons 'string? string?)
                    (cons 'boolean? boolean?)
                    (cons 'char? char?)
                    (cons 'null? null?)
                    (cons 'symbol? symbol?)
                    (cons 'list? list?)
                    (cons 'equal? equal?)
                    (cons '<= <=)
                    (cons '>= >=)
                    (cons '< <)
                    (cons '> >)
                    (cons '+ +)
                    (cons '- -)
                    (cons '* *)
                    (cons '/ /)
                    (cons 'list list)
                    (cons 'car car)
                    (cons 'cdr cdr)
                    (cons 'cons cons)
                    (cons 'set-car! set-car!)
                    (cons 'set-cdr! set-cdr!)
                    ))

;taken from page 280 of "The Scheme Programming Language" by Kent Dybvig
(define (readfile filename)
  (let ((p (open-input-file filename)))
    (let f ((x (read p)))
      (if (eof-object? x)
          (begin
            (close-port p)
            '())
          (begin
          (evaluate x  global-env) (f (read p)))))))


    

(define (handle-symbol symb env)
  (if (equal? (assoc symb env) #f)
      (begin (display "Unbound variable: ")
             (display (string symb))
             (display ".\n") "*Unspec*")
      (cdr (assoc symb env))
      ))

(define (fix-format expr)
  (evaluate
   (list 'define (caar expr) (list 'lambda (cdar expr) (cadr expr)))
   global-env)
  )

;Chris helped my figure out what define needed to say
(define (handle-define expr env)
  (if (list? (car expr))
      (fix-format expr)
      (let ( (head (car global-env)) (tail (cdr global-env)) )
        (set-cdr! global-env (cons (cons (car head) (cdr head)) tail))
        (set-car! global-env (cons (car expr) (evaluate (cadr expr) env)))
        "*Unspec*"
        )))

(define (let-help pairs env)
  (if (equal? '() pairs)
      env
      (cons (cons (caar pairs) (cadar pairs)) (let-help (cdr pairs) env))
      ))

(define (handle-let expr env)
  (evaluate (cons 'begin (cdr expr)) (let-help (car expr) env))
  )

(define (handle-if expr env)
  (if (evaluate (car expr) env)
      (evaluate (cadr expr) env)
      (evaluate (caddr expr) env)
      ))

(define (handle-cond expr env)
  (if (equal? '() expr)
      (begin (display "All conditions failed, please try again.\n") "*Unspec*")
      (if (equal? 'else (caar expr))
          (evaluate (cadar expr) env)
          (if (evaluate (caar expr) env)
              (evaluate (cadar expr) env)
              (handle-cond (cdr expr) env))
          )))

(define (handle-begin lst env)
  (if (equal? '() (cdr lst))
      (evaluate (car lst) env)
      (begin (evaluate (car lst) env) (handle-begin (cdr lst) env))
      ))

(define (handle-lambda expr env)
  (list 'closure expr env)
  )

(define (create-env pairs env)
  (if (equal? (cdr pairs) '())
      (cons (car pairs) env)
      (cons (car pairs) (create-env (cdr pairs) env))
      ))

(define (eval-all expr env)
  (if (equal? '() expr)
      '()
      (cons (evaluate (car expr) env) (eval-all (cdr expr) env))
      ))

(define (zip lst1 lst2)
  (if (equal? lst1 '())
      '()
      (cons (cons (car lst1) (car lst2)) (zip (cdr lst1) (cdr lst2)))
      ))

(define (function-apply name func args)
  (if (equal? (length (cadadr func)) (length args))
      (evaluate (caddadr func) (create-env (zip (cadadr func) args)
                                           (caddr func)))
      (mess-up name (length (cadadr func)) (+ (length args) 1))
      ))

(define (handle-else expr env)
  (if (equal? #f (assoc (car expr) env))
      (begin
        (display "Failed to find procedure: ")
        (display (string (car expr)))
        (display ".\n") "*Unspec*")
      (let ( (func (cdr (assoc (car expr) env)))
             (args (eval-all (cdr expr) env)) )
        (if (check-unspec? args) "*Unspec*"
            (if (procedure? func)
                (apply func args)
                (function-apply (car expr) func args)
                )))))

(define (check-unspec? expr)
  (if (equal? '() expr)
      #f
      (if (equal? "*Unspec*" (car expr))
          #t
          (check-unspec? (cdr expr))
          )))

(define (evaluate expr env)
  (cond
   ((equal? "*Unspec*" expr) "*Unspec*")
   ((number? expr) expr)
   ((string? expr) expr)
   ((boolean? expr) expr)
   ((char? expr)  expr)
   ((null? expr) null)
   ((equal? 'user-initial-environment expr) global-env)
   ((symbol? expr) (handle-symbol expr env))
   ((list? expr)
    (cond
     ((equal? '() expr) '())
     ((check-unspec? expr) "*Unspec*")
     ((equal? 'define (car expr)) (if (equal? 3 (length expr))
                                      (handle-define (cdr expr) env)
                                      (mess-up 'define 2 (length expr))))
     ((equal? 'quote (car expr)) (if (equal? 2 (length expr))
                                      (cadr expr)
                                      (mess-up 'quote 1 (length expr))))
     ((equal? 'let (car expr)) (if (<= 3 (length expr))
                                      (handle-let (cdr expr) env)
                                      (mess-up2 'let 2 (length expr))))
     ((equal? 'if (car expr)) (if (equal? 4 (length expr))
                                      (handle-if (cdr expr) env)
                                      (mess-up 'if 3 (length expr))))
     ((equal? 'cond (car expr)) (if (<= 2 (length expr))
                                      (handle-cond (cdr expr) env)
                                      (mess-up2 'cond 1 (length expr))))
     ((equal? 'begin (car expr)) (if (<= 2 (length expr))
                                      (handle-begin (cdr expr) env)
                                      (mess-up2 'begin 1 (length expr))))
     ((equal? 'lambda (car expr)) (if (equal? 3 (length expr))
                                      (handle-lambda expr env)
                                      (mess-up 'lambda 2 (length expr))))
     ((equal? 'eval (car expr)) (if (equal? 3 (length expr))
                                    (evaluate 
                                     (evaluate (cadr expr) env)
                                     (evaluate (caddr expr) env))
                                    (mess-up 'eval 2 (length expr))))
     ((equal? 'assoc (car expr)) (if (equal? 3 (length expr))
                                      (my-assoc (cadr expr) (caddr expr))
                                      (mess-up 'assoc 2 (length expr))))
     ((equal? 'map (car expr)) (if (equal? 3 (length expr))
                                      (my-map (cadr expr) (caddr expr))
                                      (mess-up 'map 2 (length expr))))
     ((equal? 'reduce (car expr)) (if (equal? 4 (length expr))
                                      (my-reduce
                                       (cadr expr) (caddr expr) (cadddr expr))
                                      (mess-up 'reduce 3 (length expr))))
     ((equal? 'display (car expr)) (if (equal? 2 (length expr))
                                       (my-display (cadr expr))
                                       (mess-up 'display 1 (length expr))))
;     ((equal? 'apply (car expr)) (if (equal? 3 (length expr))
;                                     (my-apply (cdr expr) env)
;                                     (mess-up 'apply 2 (length expr))))
     ((equal? 'load (car expr)) (handle-load (cadr expr)))
     ((equal? 'caar (car expr)) (my-caar (cadr expr)))
     ((equal? 'cddr (car expr)) (my-cddr (cadr expr)))
     ((equal? 'cdar (car expr)) (my-cdar (cadr expr)))
     ((equal? 'cadr (car expr)) (my-cadr (cadr expr)))
     ((equal? 'caddr (car expr)) (my-caddr (cadr expr)))
     ((equal? 'cadddr (car expr)) (my-cadddr (cadr expr)))
     ((equal? 'cadar (car expr)) (my-cadar (cadr expr)))
     ((equal? 'cadadr (car expr)) (my-cadadr (cadr expr)))
     ((equal? 'caddadr (car expr)) (caddadr (cadr expr)))
     ((equal? 'cadddadr (car expr)) (cadddadr (cadr expr)))
     (else (handle-else expr env))
     ))))

(define (mess-up func allow given)
  (begin
    (display ";The procedure '") (display func)
    (display "' has been called with ") (display (- given 1))
    (display " argument(s); it requires exactly ") (display allow)
    (display " argument(s).\n") "*Unspec*"))

(define (mess-up2 func allow given)
  (begin
    (display ";The procedure '") (display func)
    (display "' has been called with ") (display (- given 1))
    (display " argument(s); it requires at least ") (display allow)
    (display " argument(s).\n") "*Unspec*"))

(define (my-display item)
  (cond
   ((equal? "*Unspec*" item) '())
   ((list? item) (begin (display item) (display "\n")))
   ((number? item) (begin (display item) (display "\n")))
   ((string? item) (begin (display ";Value 13: \"")
                          (display item) (display "\"\n")))
   ((boolean? item) (begin (display item) (display "\n")))
   ((char? item) (begin (display item) (display "\n")))
   ((symbol? item) (begin (display item) (display "\n")))
   ((procedure? item) (begin (display "Procedure: ") (display item)
                             (display "\n")))
   ((equal? 'closure (car item)) (display "Closure.\n"))
   ((null? item) '())
   (else '())
   ))

(define (my-caar lst) (car (car lst)))
(define (my-cddr lst) (cdr (cdr lst)))
(define (my-cdar lst) (cdr (car lst)))
(define (my-cadr lst) (car (cdr lst)))
(define (my-caddr lst) (car (cdr (cdr lst))))
(define (my-cadddr lst) (car (cdr (cdr (cdr lst)))))
(define (my-cadar lst) (car (cdr (car lst))))
(define (my-cadadr lst) (car (cdr (car (cdr lst)))))
(define (caddadr lst) (car (cdr (cdr (car (cdr lst))))))
(define (cadddadr lst) (car (cdr (cdr (cdr (car (cdr lst)))))))

(define (my-assoc symbol lst)
  (if (null? lst)
      (if (equal? symbol (caar lst))
          (car lst)
          (assoc symbol (cdr lst))
          )))
(define (my-map func lst)
  (if (equal? '() lst)
      '()
      (cons (func (car lst)) (my-map func (cdr lst)))
      ))

(define (my-reduce func n lst)
  (if (equal? '() lst)
      n
      (func (car lst) (my-reduce func n (cdr lst)))
      ))

;(define (my-apply expr args env)
;  (evaluate (cons (evaluate (car expr) env) (cadr expr)) env)
;  )

(define (length lst)
  (if (equal? '() lst)
      0
      (+ 1 (length (cdr lst)))
      ))

(display "\n=> ")
(define (start-interp)
  (let ((input (read)))
    (if (equal? 'exit input)
        '()
        (begin
          (my-display (evaluate input global-env))
          (display "=> ")
          (start-interp)
          ))))

(start-interp)
(display "Happy Happy Joy Joy")
